//===- ProtoOpSerializerGen.cpp - Proto op serializer generator -----------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// ProtoOpDefinitionsGen uses the description of operations to generate Proto
// definitions for ops.
//
//===----------------------------------------------------------------------===//

#include "OpGenHelpers.h"
#include "mlir/TableGen/CodeGenHelpers.h"
#include "mlir/TableGen/GenInfo.h"
#include "mlir/TableGen/Operator.h"
#include "mlir/TableGen/Pass.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"

#include <map>
#include <set>
#include <string>

using namespace llvm;
using namespace mlir;
using namespace mlir::tblgen;
using llvm::formatv;
using llvm::RecordKeeper;

const char *const serializerFileHeader = R"(
#include "cir-tac/Serializer.h"

#include <llvm/ADT/TypeSwitch.h>

using namespace protocir;
)";

const char *const serializerDefStart = R"(
void Serializer::serializeOperation(mlir::Operation &inst,
                                    protocir::CIROp *pInst,
                                    protocir::CIRModuleID pModuleID,
                                    TypeCache &typeCache,
                                    OperationCache &opCache,
                                    FunctionCache &functionCache

) {
  auto instID = internOperation(opCache, &inst);
  llvm::TypeSwitch<mlir::Operation *>(&inst)
)";

const char *const serializerDefEnd = R"(
}
)";

const char *const serializerCaseStart = R"(
      .Case<cir::{0}>([instID, pInst, pModuleID, &typeCache](cir::{0} op) {{
        protocir::CIR{0} p{0};
        pInst->mutable_base()->set_id(instID);
)";

const char *const serializerCaseOffset = R"(
        {0}
)";

const char *const serializerCaseEnd = R"(
        pInst->mutable_{0}()->CopyFrom(p{1});
      })
)";

const char *const serializerDefaultCase = R"(
      .Default([](mlir::Operation *op) {
        op->dump();
        llvm_unreachable("NIY");
      });
)";

const char *const protoOpMessageStart = R"(
message CIR{0} {{)";

const char *const protoOpMessageField = R"(
  {0} {1} = {2};)";

const char *const protoOpMessageEnd = R"(
}
)";

const std::map<StringRef, StringRef> cppTypeToProto = {
    {"::mlir::DenseI32ArrayAttr", "repeated uint32"},
    {"::mlir::IntegerAttr", "uint64"},
    {"::cir::VisibilityAttr", "CIRVisibilityKind"},
    {"::mlir::FloatAttr", "double"},
    {"::mlir::UnitAttr", "google.protobuf.Empty"},
    {"::cir::GlobalCtorAttr", "google.protobuf.Empty"},
    {"::cir::GlobalDtorAttr", "google.protobuf.Empty"},
    {"::mlir::TypedAttr", "google.protobuf.Any"},
    {"::mlir::StringAttr", "string"},
    {"::mlir::FlatSymbolRefAttr", "string"},
    {"::mlir::TypeAttr", "CIRTypeID"},
    {"::mlir::Type", "CIROpID"},
    {"::cir::PointerType", "CIROpID"},
    {"::cir::IntType", "CIROpID"},
    {"::cir::MethodType", "CIROpID"},
    {"::cir::DataMemberType", "CIROpID"},
    {"::cir::ComplexType", "CIROpID"},
    {"::cir::VectorType", "CIROpID"},
    {"::cir::BoolType", "CIROpID"}};

const std::set<StringRef> typeBlackList = {"::mlir::ArrayAttr",
                                           "::cir::ASTVarDeclInterface",
                                           "::cir::ASTCallExprInterface",
                                           "::cir::CmpThreeWayInfoAttr",
                                           "::cir::DynamicCastInfoAttr",
                                           "::mlir::Attribute",
                                           "::cir::BitfieldInfoAttr",
                                           "::cir::AddressSpaceAttr",
                                           "::cir::ExtraFuncAttributesAttr"};

static bool emitOpProtoSerializer(const RecordKeeper &records,
                                  raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << serializerFileHeader;
  os << serializerDefStart;

  std::vector<const Record *> defs = getRequestedOpDefinitions(records);
  for (auto *def : defs) {
    Operator op(*def);
    const int numOperands = op.getNumOperands();
    os << formatv(serializerCaseStart, op.getCppClassName());
    int messageIdx = 0;
    for (int i = 0; i != numOperands; ++i, ++messageIdx) {
      const auto &operand = op.getOperand(i);
      const auto &operandType = operand.constraint.getCppType();
      if (operand.name.empty())
        continue;
      if (typeBlackList.count(operandType)) {
        --messageIdx;
      } else if (operand.isOptional()) {
        // os << formatv(protoOpMessageField,
        //               formatv("optional {0}", operandType), operand.name,
        //               std::to_string(messageIdx + 1));
      } else if (operand.isVariadic()) {
        // os << formatv(protoOpMessageField,
        //               formatv("repeated {0}", operandType), operand.name,
        //               std::to_string(messageIdx + 1));
      } else {
        os << formatv(protoOpMessageField, operandType, operand.name,
                      std::to_string(messageIdx + 1));
      }
    }
    os << "\n";
    // const int numAttributes = op.getNumNativeAttributes();
    // for (int i = 0; i != numAttributes; ++i, ++messageIdx) {
    //   const auto &rawAttr = op.getAttribute(i).attr;
    //   const auto &rawAttrName = op.getAttribute(i).name;
    //   if (rawAttrName.empty())
    //     continue;
    //   const auto &attr =
    //       rawAttr.hasDefaultValue() ? rawAttr.getBaseAttr() : rawAttr;
    //   auto it = cppTypeToProto.find(attr.getStorageType().str());
    //   auto &attrType =
    //       it != cppTypeToProto.end() ? it->second : attr.getStorageType();
    //   if (typeBlackList.count(attrType)) {
    //     --messageIdx;
    //   } else if (attr.isEnumAttr()) {
    //     EnumAttr enumAttr(attr.getDef());
    //     StringRef enumName = enumAttr.getEnumClassName();
    //     os << formatv(protoOpMessageField, formatv("CIR{0}", enumName),
    //                   rawAttrName, std::to_string(messageIdx + 1));
    //   } else if (attr.isOptional() && attr.getBaseAttr().isEnumAttr()) {
    //     EnumAttr enumAttr(attr.getBaseAttr().getDef());
    //     StringRef enumName = enumAttr.getEnumClassName();
    //     os << formatv(protoOpMessageField, formatv("optional CIR{0}",
    //     enumName),
    //                   rawAttrName, std::to_string(messageIdx + 1));
    //   } else if (attr.isOptional()) {
    //     os << formatv(protoOpMessageField, formatv("optional {0}", attrType),
    //                   rawAttrName, std::to_string(messageIdx + 1));
    //   } else {
    //     os << formatv(protoOpMessageField, attrType, rawAttrName,
    //                   std::to_string(messageIdx + 1));
    //   }
    // }
    // os << formatv(protoOpMessageEnd);
    os << formatv(serializerCaseEnd,
                  llvm::convertToSnakeFromCamelCase(op.getCppClassName()),
                  op.getCppClassName());
  }
  os << serializerDefaultCase;

  os << serializerDefEnd;
  return false;
}

static mlir::GenRegistration
    genOpSerializerProto("gen-op-ser-proto",
                         "Generate serializer to op Proto definitions",
                         &emitOpProtoSerializer);
