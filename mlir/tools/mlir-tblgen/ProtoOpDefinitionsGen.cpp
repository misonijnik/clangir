//===- ProtoOpDefinitionsGen.cpp - Proto op definitions generator ---------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// ProtoOpDefinitionsGen uses the description of operations to generate Proto
// definitions for ops.
//
//===----------------------------------------------------------------------===//

#include "OpGenHelpers.h"
#include "mlir/TableGen/CodeGenHelpers.h"
#include "mlir/TableGen/GenInfo.h"
#include "mlir/TableGen/Operator.h"
#include "mlir/TableGen/Pass.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include <string>

using namespace llvm;
using namespace mlir;
using namespace mlir::tblgen;
using llvm::formatv;
using llvm::RecordKeeper;

static llvm::cl::OptionCategory protoGenCat("Options for -gen-op-proto");
static llvm::cl::opt<std::string> protoGroupName(
    "proto-prefix",
    llvm::cl::desc("The prefix to use for this group of passes. The "
                   "form will be mlirCreate<prefix><passname>, the "
                   "prefix can avoid conflicts across libraries."),
    llvm::cl::cat(protoGenCat));

const char *const protoFileHeader = R"(
syntax = "proto3";

package protocir;
option java_package = "org.jacodb.impl.grpc";

import "setup.proto";
)";

const char *const protoOpMessageStart = R"(
message CIR{0} {{)";

const char *const protoOpMessageField = R"(
  {0} {1} = {2};)";

const char *const protoOpMessageEnd = R"(
}
)";

const std::map<StringRef, StringRef> cppTypeToProto = {
    {"::mlir::TypeAttr", "CIRTypeID"}, {"::mlir::Type", "CIROpID"},
    {"::cir::PointerType", "CIROpID"}, {"::cir::IntType", "CIROpID"},
    {"::cir::MethodType", "CIROpID"},  {"::cir::DataMemberType", "CIROpID"},
    {"::cir::ComplexType", "CIROpID"}, {"::cir::VectorType", "CIROpID"},
    {"::cir::BoolType", "CIROpID"}};

static bool emitOpProtoDefs(const RecordKeeper &records, raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << protoFileHeader;

  std::vector<const Record *> defs = getRequestedOpDefinitions(records);
  for (auto *def : defs) {
    Operator op(*def);
    const int numOperands = op.getNumOperands();
    os << formatv(protoOpMessageStart, op.getCppClassName());
    int messageIdx = 0;
    for (int i = 0; i != numOperands; ++i, ++messageIdx) {
      const auto &operand = op.getOperand(i);
      const auto &operandType = operand.constraint.getCppType();
      auto it = cppTypeToProto.find(operandType);
      const auto &operandTypeProto =
          it != cppTypeToProto.end() ? it->second : operandType;
      if (operand.name.empty())
        continue;
      if (operand.isOptional()) {
        os << formatv(protoOpMessageField,
                      formatv("optional {0}", operandTypeProto), operand.name,
                      std::to_string(messageIdx + 1));
      } else if (operand.isVariadic()) {
        os << formatv(protoOpMessageField,
                      formatv("repeated {0}", operandTypeProto), operand.name,
                      std::to_string(messageIdx + 1));
      } else {
        os << formatv(protoOpMessageField, operandTypeProto, operand.name,
                      std::to_string(messageIdx + 1));
      }
    }
    os << "\n";
    const int numAttributes = op.getNumNativeAttributes();
    for (int i = 0; i != numAttributes; ++i, ++messageIdx) {
      const auto &attr = op.getAttribute(i);
      if (attr.name.empty())
        continue;
      auto it = cppTypeToProto.find(attr.attr.getStorageType().str());
      auto &attrType =
          it != cppTypeToProto.end() ? it->second : attr.attr.getStorageType();
      if (attr.attr.isOptional()) {
        os << formatv(protoOpMessageField, formatv("optional {0}", attrType),
                      attr.name, std::to_string(messageIdx + 1));
      } else {
        os << formatv(protoOpMessageField, attrType, attr.name,
                      std::to_string(messageIdx + 1));
      }
    }
    os << formatv(protoOpMessageEnd);
  }
  return false;
}

static mlir::GenRegistration genOpProto("gen-op-proto",
                                        "Generate op Proto definitions",
                                        &emitOpProtoDefs);
