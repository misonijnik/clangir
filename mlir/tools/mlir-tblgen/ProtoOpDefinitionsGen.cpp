//===- ProtoOpDefinitionsGen.cpp - Proto op definitions generator ---------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// ProtoOpDefinitionsGen uses the description of operations to generate Proto
// definitions for ops.
//
//===----------------------------------------------------------------------===//

#include "OpGenHelpers.h"
#include "mlir/TableGen/CodeGenHelpers.h"
#include "mlir/TableGen/GenInfo.h"
#include "mlir/TableGen/Operator.h"
#include "mlir/TableGen/Pass.h"
#include "mlir/TableGen/Type.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"

#include <map>
#include <set>
#include <string>

using namespace llvm;
using namespace mlir;
using namespace mlir::tblgen;
using llvm::formatv;
using llvm::RecordKeeper;

const char *const protoFileHeader = R"(
syntax = "proto3";

package protocir;
option java_package = "org.jacodb.impl.grpc";

import "setup.proto";
import "enumgen.proto";
)";

const char *const protoOpMessageStart = R"(
message CIR{0} {{)";

const char *const protoOpMessageField = R"(
  {0} {1} = {2};)";

const char *const protoOpMessageEnd = R"(
}
)";

const char *const protoCirOpMessageStart = R"(
message CIROp {{
  CIROpID base = 1;
  repeated CIRTypeID result_types = 2;
  oneof operation {{
)";

const char *const protoCirOpMessageEnd = R"(
  }
}
)";

const char *const protoCirOpMessageField = R"(
    CIR{0} {1} = {2};)";

const std::map<StringRef, StringRef> cppAttrTypeToProto = {
    {"uint64_t", "uint64"},
    {"uint32_t", "uint32"},
    {"::llvm::StringRef", "string"},
    {"::llvm::APInt", "string"},
    {"::llvm::APFloat", "string"},
    {"::cir::GlobalDtorAttr", "bool"},
    {"::cir::GlobalCtorAttr", "bool"},
    {"::llvm::ArrayRef<int32_t>", "repeated uint32"},
    {"::mlir::Attribute", "string"},
    {"::mlir::TypedAttr", "string"},
    {"::cir::VisibilityAttr", "CIRVisibilityKind"},
    {"::cir::FuncType", "CIRTypeID"},
    {"::mlir::Type", "CIRTypeID"},
    {"::cir::PointerType", "CIROpID"},
    {"::cir::IntType", "CIROpID"},
    {"::cir::MethodType", "CIROpID"},
    {"::cir::DataMemberType", "CIROpID"},
    {"::cir::ComplexType", "CIROpID"},
    {"::cir::VectorType", "CIROpID"},
    {"::cir::BoolType", "CIROpID"}};

const std::map<StringRef, StringRef> cppOperandTypeToProto = {
    {"uint64_t", "uint64"},
    {"uint32_t", "uint32"},
    {"::llvm::StringRef", "string"},
    {"::llvm::APInt", "string"},
    {"::llvm::APFloat", "string"},
    {"::llvm::ArrayRef<int32_t>", "repeated uint32"},
    {"::mlir::TypedAttr", "string"},
    {"::cir::VisibilityAttr", "CIRVisibilityKind"},
    {"::cir::FuncType", "CIROpID"},
    {"::mlir::Type", "CIROpID"},
    {"::cir::PointerType", "CIROpID"},
    {"::cir::IntType", "CIROpID"},
    {"::cir::MethodType", "CIROpID"},
    {"::cir::DataMemberType", "CIROpID"},
    {"::cir::ComplexType", "CIROpID"},
    {"::cir::VectorType", "CIROpID"},
    {"::cir::BoolType", "CIROpID"}};

const std::set<StringRef> typeBlackList = {
    "::std::optional< ::mlir::ArrayAttr >",
    "::std::optional<::cir::DynamicCastInfoAttr>",
    "::std::optional<::cir::ASTVarDeclInterface>",
    "::mlir::ArrayAttr",
    "::cir::CmpThreeWayInfoAttr",
    "::cir::BitfieldInfoAttr",
    "::std::optional<::cir::AddressSpaceAttr>",
    "::std::optional<::cir::ASTCallExprInterface>",
    "::cir::ExtraFuncAttributesAttr"};

static bool emitOpProtoDefs(const RecordKeeper &records, raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << protoFileHeader;

  std::vector<const Record *> defs = getRequestedOpDefinitions(records);
  os << formatv(protoCirOpMessageStart);
  int caseIdx = 2;
  for (auto *def : defs) {
    Operator op(*def);
    os << formatv(protoCirOpMessageField, op.getCppClassName(),
                  llvm::convertToSnakeFromCamelCase(op.getCppClassName()),
                  ++caseIdx);
  }
  os << formatv(protoCirOpMessageEnd);

  for (auto *def : defs) {
    Operator op(*def);
    const int numOperands = op.getNumOperands();
    os << formatv(protoOpMessageStart, op.getCppClassName());
    int messageIdx = 0;
    for (int i = 0; i != numOperands; ++i, ++messageIdx) {
      const auto &operand = op.getOperand(i);
      const auto &operandType = operand.constraint.getCppType();
      if (operand.name.empty())
        continue;
      const auto &operandName = llvm::convertToSnakeFromCamelCase(operand.name);
      if (typeBlackList.count(operandType)) {
        --messageIdx;
      } else if (operand.isOptional()) {
        const auto &operandTypeOptional =
            TypeConstraint(
                operand.constraint.getDef().getValueAsOptionalDef("baseType"))
                .getCppType();
        auto it = cppOperandTypeToProto.find(operandTypeOptional);
        const auto &operandTypeProto = it != cppOperandTypeToProto.end()
                                           ? it->second
                                           : operandTypeOptional;
        os << formatv(protoOpMessageField,
                      formatv("optional {0}", operandTypeProto), operandName,
                      std::to_string(messageIdx + 1));
      } else if (operand.isVariadicOfVariadic()) {
        auto it = cppOperandTypeToProto.find(operandType);
        const auto &operandTypeProto =
            it != cppOperandTypeToProto.end() ? it->second : operandType;
        assert(operandTypeProto == "CIROpID");
        os << formatv(protoOpMessageField, "repeated CIROpIDs", operandName,
                      std::to_string(messageIdx + 1));
      } else if (operand.isVariadic()) {
        auto it = cppOperandTypeToProto.find(operandType);
        const auto &operandTypeProto =
            it != cppOperandTypeToProto.end() ? it->second : operandType;
        os << formatv(protoOpMessageField,
                      formatv("repeated {0}", operandTypeProto), operandName,
                      std::to_string(messageIdx + 1));
      } else {
        auto it = cppOperandTypeToProto.find(operandType);
        const auto &operandTypeProto =
            it != cppOperandTypeToProto.end() ? it->second : operandType;
        os << formatv(protoOpMessageField, operandTypeProto, operandName,
                      std::to_string(messageIdx + 1));
      }
    }
    os << "\n";
    const int numAttributes = op.getNumNativeAttributes();
    for (int i = 0; i != numAttributes; ++i, ++messageIdx) {
      const auto &attr = op.getAttribute(i).attr;
      const auto &attrName =
          llvm::convertToSnakeFromCamelCase(op.getAttribute(i).name);
      if (attrName.empty())
        continue;
      const auto &attrType = attr.getReturnType();
      if (typeBlackList.count(attrType)) {
        --messageIdx;
      } else if (attr.isEnumAttr()) {
        EnumAttr enumAttr(attr.getDef());
        StringRef enumName = enumAttr.getEnumClassName();
        os << formatv(protoOpMessageField, formatv("CIR{0}", enumName),
                      attrName, std::to_string(messageIdx + 1));
      } else if (attr.isOptional() && attr.getBaseAttr().isEnumAttr()) {
        EnumAttr enumAttr(attr.getBaseAttr().getDef());
        StringRef enumName = enumAttr.getEnumClassName();
        os << formatv(protoOpMessageField, formatv("optional CIR{0}", enumName),
                      attrName, std::to_string(messageIdx + 1));
      } else if (attr.hasDefaultValue() && attr.getBaseAttr().isEnumAttr()) {
        EnumAttr enumAttr(attr.getBaseAttr().getDef());
        StringRef enumName = enumAttr.getEnumClassName();
        os << formatv(protoOpMessageField, formatv("CIR{0}", enumName),
                      attrName, std::to_string(messageIdx + 1));
      } else if (attr.isOptional()) {
        Attribute baseAttr(&attr.getBaseAttr().getDef());
        const auto &baseAttrType = baseAttr.getReturnType();
        auto it = cppAttrTypeToProto.find(baseAttrType);
        auto &attrTypeProto =
            it != cppAttrTypeToProto.end() ? it->second : baseAttrType;
        if (attrTypeProto == "bool") {
          os << formatv(protoOpMessageField, attrTypeProto, attrName,
                        std::to_string(messageIdx + 1));
        } else {

          os << formatv(protoOpMessageField,
                        formatv("optional {0}", attrTypeProto), attrName,
                        std::to_string(messageIdx + 1));
        }
      } else {
        auto it = cppAttrTypeToProto.find(attrType);
        auto &attrTypeProto =
            it != cppAttrTypeToProto.end() ? it->second : attrType;
        os << formatv(protoOpMessageField, attrTypeProto, attrName,
                      std::to_string(messageIdx + 1));
      }
    }
    os << "\n";
    unsigned numSuccessors = op.getNumSuccessors();
    for (unsigned i = 0; i != numSuccessors; ++i, ++messageIdx) {
      const NamedSuccessor &successor = op.getSuccessor(i);
      if (successor.name.empty())
        continue;
      const auto &successorName =
          llvm::convertToSnakeFromCamelCase(successor.name);
      if (successor.isVariadic()) {
        os << formatv(protoOpMessageField, "repeated CIRBlockID", successorName,
                      std::to_string(messageIdx + 1));
      } else {
        os << formatv(protoOpMessageField, "CIRBlockID", successorName,
                      std::to_string(messageIdx + 1));
      }
    }
    os << formatv(protoOpMessageEnd);
  }
  return false;
}

static mlir::GenRegistration genOpProto("gen-op-proto",
                                        "Generate op Proto definitions",
                                        &emitOpProtoDefs);
