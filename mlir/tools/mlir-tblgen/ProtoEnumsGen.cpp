//===- EnumsGen.cpp - MLIR enum utility generator -------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// EnumsGen generates common utility functions for enums.
//
//===----------------------------------------------------------------------===//

#include "FormatGen.h"
#include "mlir/TableGen/Attribute.h"
#include "mlir/TableGen/Format.h"
#include "mlir/TableGen/GenInfo.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"

using llvm::formatv;
using llvm::isDigit;
using llvm::Record;
using llvm::RecordKeeper;
using namespace mlir;
using mlir::tblgen::EnumAttr;
using mlir::tblgen::EnumAttrCase;

static std::string makeIdentifier(StringRef str) {
  if (!str.empty() && isDigit(static_cast<unsigned char>(str.front()))) {
    std::string newStr = std::string("_") + str.str();
    return newStr;
  }
  return str.str();
}

const char *const protoFileHeader = R"(
syntax = "proto3";

package protocir;
option java_package = "org.jacodb.impl.grpc";

import "google/protobuf/empty.proto";
import "setup.proto";
)";

const char *const protoEnumMessageStart = R"(
enum CIR{0} {{)";

const char *const protoEnumMessageField = R"(
  {0} = {1};)";

const char *const protoEnumMessageEnd = R"(
}
)";

static void emitEnumProto(StringRef enumName, StringRef description,
                          const std::vector<EnumAttrCase> &enumerants,
                          raw_ostream &os) {
  os << "// " << description << "\n";
  os << formatv(protoEnumMessageStart, enumName);

  int messageIdx = 0;
  for (const auto &enumerant : enumerants) {
    auto symbol = llvm::convertToCamelFromSnakeCase(
        makeIdentifier(enumerant.getSymbol()), true);
    os << formatv(protoEnumMessageField, formatv("{0}_{1}", enumName, symbol),
                  std::to_string(messageIdx++));
  }
  os << formatv(protoEnumMessageEnd);
}

static void emitEnumProtoDef(const Record &enumDef, raw_ostream &os) {
  EnumAttr enumAttr(enumDef);
  StringRef enumName = enumAttr.getEnumClassName();
  StringRef description = enumAttr.getSummary();
  auto enumerants = enumAttr.getAllCases();

  // Emit the enum definition
  emitEnumProto(enumName, description, enumerants, os);
}

static bool emitEnumProtoDefs(const RecordKeeper &records, raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << protoFileHeader;
  auto defs = records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo");

  for (const Record *def : defs)
    emitEnumProtoDef(*def, os);

  return false;
}

static mlir::GenRegistration genEnumProto("gen-enum-proto",
                                          "Generate enum utility Proto",
                                          &emitEnumProtoDefs);
