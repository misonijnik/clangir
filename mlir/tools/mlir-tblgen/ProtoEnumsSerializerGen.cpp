//===- ProtoEnumsSerializerGen.cpp - MLIR enum utility generator ----------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// EnumsGen generates common utility functions for enums.
//
//===----------------------------------------------------------------------===//

#include "FormatGen.h"
#include "mlir/TableGen/Attribute.h"
#include "mlir/TableGen/Format.h"
#include "mlir/TableGen/GenInfo.h"
#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"

using llvm::formatv;
using llvm::isDigit;
using llvm::Record;
using llvm::RecordKeeper;
using namespace mlir;
using mlir::tblgen::EnumAttr;
using mlir::tblgen::EnumAttrCase;

static std::string makeIdentifier(StringRef str) {
  if (!str.empty() && isDigit(static_cast<unsigned char>(str.front()))) {
    std::string newStr = std::string("_") + str.str();
    return newStr;
  }
  return str.str();
}

const char *const serializerDeclfFileHeader = R"(
#include "proto/enumgen.pb.h"

#include <clang/CIR/Dialect/IR/CIRDialect.h>
)";

const char *const serializerDeffFileHeader = R"(
#include "cir-tac/EnumsSerializer.h"

using namespace protocir;
)";

const char *const serializerDeclStart = R"(
namespace protocir {
class EnumSerializer {
)";

const char *const serializerDeclEnum = R"(
  static protocir::CIR{0}
  serialize{0}({1} &cirKind);
)";

const char *const serializerDeclEnd = R"(
};
} // namespace protocir
)";

const char *const serializerDefEnumStart = R"(
CIR{0}
EnumSerializer::serialize{0}({1} &cirKind) {{
  switch (cirKind) {{
)";

const char *const serializerDefEnumCase = R"(
  case {1}::{2}:
    return protocir::CIR{0}::{3};
)";

const char *const serializerDefEnumEnd = R"(
  }
}
)";

static void
emitEnumProtoSerializerDef(StringRef enumName, StringRef fullEnumName,
                           const std::vector<EnumAttrCase> &enumerants,
                           raw_ostream &os) {
  os << formatv(serializerDefEnumStart, enumName, fullEnumName);

  for (const auto &enumerant : enumerants) {
    auto symbol = makeIdentifier(enumerant.getSymbol());
    os << formatv(serializerDefEnumCase, enumName, fullEnumName, symbol,
                  formatv("{0}_{1}", enumName, symbol));
  }
  os << formatv(serializerDefEnumEnd);
}

static void emitEnumProtoSerializerDecl(StringRef enumName,
                                        StringRef fullEnumName,
                                        StringRef description,
                                        raw_ostream &os) {
  os << "// " << description;
  os << formatv(serializerDeclEnum, enumName, fullEnumName);
  os << "\n";
}

static void emitEnumProtoSerializer(const Record &enumDef, raw_ostream &os,
                                    bool emitDecl) {
  EnumAttr enumAttr(enumDef);
  StringRef enumName = enumAttr.getEnumClassName();
  StringRef namespaceName = enumAttr.getCppNamespace();
  StringRef description = enumAttr.getSummary();
  auto enumerants = enumAttr.getAllCases();

  if (emitDecl) {
    // Emit the enum serializer declarations
    emitEnumProtoSerializerDecl(
        enumName, formatv("{0}::{1}", namespaceName, enumName).str(),
        description, os);
  } else {
    // Emit the enum serializer definition
    emitEnumProtoSerializerDef(
        enumName, formatv("{0}::{1}", namespaceName, enumName).str(),
        enumerants, os);
  }
}

static bool emitEnumProtoSerializerDecls(const RecordKeeper &records,
                                         raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << serializerDeclfFileHeader;
  auto defs = records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo");

  os << serializerDeclStart;
  for (const Record *def : defs)
    emitEnumProtoSerializer(*def, os, /*emitDecl=*/true);
  os << serializerDeclEnd;

  return false;
}

static bool emitEnumProtoSerializerDefs(const RecordKeeper &records,
                                        raw_ostream &os) {
  os << "/* Autogenerated by mlir-tblgen; don't manually edit. */\n";
  os << serializerDeffFileHeader;
  auto defs = records.getAllDerivedDefinitionsIfDefined("EnumAttrInfo");

  for (const Record *def : defs)
    emitEnumProtoSerializer(*def, os, /*emitDecl=*/false);

  return false;
}

static mlir::GenRegistration
    genEnumSerializerProtoDecls("gen-enum-ser-proto-decls",
                                "Generate enum utility Proto",
                                &emitEnumProtoSerializerDecls);
static mlir::GenRegistration
    genEnumSerializerProtoDefs("gen-enum-ser-proto-defs",
                               "Generate enum utility Proto",
                               &emitEnumProtoSerializerDefs);
